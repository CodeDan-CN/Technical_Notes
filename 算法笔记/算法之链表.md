# 算法之链表

### 203.移除链表元素

[力扣题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)

题意：删除链表中等于给定值 val 的所有节点。

示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

示例 2：
输入：head = [], val = 1
输出：[]

示例 3：
输入：head = [7,7,7,7], val = 7
输出：[]

怎么说呢，这题应该不需要什么思路吧，霸王硬上弓就可以了。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode sentine = new ListNode(-1);
        sentine.next = head;
        ListNode lastNext = sentine;
        while( head != null ){
            if( head.val == val ){
                lastNext.next = head.next;
                head.next = null;
                head = lastNext.next;
            }else{
                head = head.next;
                lastNext = lastNext.next;
            }
        }
        return sentine.next;
    }
}
```



###  206.反转链表

[力扣题目链接](https://leetcode.cn/problems/reverse-linked-list/)

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

思路：由于单链表不具备反向性，所以大部分操作均是在从左到右去操作的，想要反转链表，那么就需要在遍历此链表的时候利用原节点重新生成一个新的链表，从而完成倒置的效果。

利用双指针去完成倒置操作，比如初始化时pre指针指向null，cur指针指向第一个节点。首先让cur指针的下一个节点变成pre，然后pre右移一位，cur指针指向第二个节点即可。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = null;
        while( cur != null ){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```



### 24. 两两交换链表中的节点

[力扣题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```



**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

思路链表双指针，简简单单

