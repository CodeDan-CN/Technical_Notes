## TCP协议为什么会有分段的说法？

想要知道为什么会分段，我们就先要知道什么是MTU，MTU是最大传输单元，是针对于网络链路层中链路对数据帧的一个限制，如果以以太网为主，那么最大的MTU为1500字节。

一般来说不超过1480字节的数据，都是以一个MTU发送的，因为网络层报文头部占20个字节。

但是如果网络层要发送的数据特别大，远远超过1480个字节的话，我们IP协议就要使用分片的策略，使用开始标识和结束标识以及内容偏移量来控制分片和重组。比如我们网络层又一个数据为3600字节，那么我们就要进行分片，首先第一个分片是20个字节的IP协议首部+1480个字节，第二个分片依然是20个字节的IP协议首部+1480个字节，第三个分片为20个字节的IP协议首部+640个字节。最后到达目标之后，通过这三个报文的开始标识，偏移量以及结束标识来重组出一个完整的运输层报文数据。

说了这么多，就是为了打个底子，为什么呢，因为TCP协议的MSS概念。

MSS为最大分段大小，完成建立且针对运输层，**为了避免网络层进行IP分片，我们必须要抑制运输层每次传输的大小**，那么怎么抑制呢，TCP将需要分片的大数据在运输层就进行分段处理，即把大数据分成一个一个MSS，每一个MSS前面都包含一个TCP首部报文。

------

## 那么MSS具体要定义成多大呢？

MSS大小的定义标准完全为了保证一个MTU能完成数据的传输，也就是说**MSS大小+TCP报文首部+IP报文首部要小于等于一个MTU，**那么标准的MSS大小就不难推算了，MSS标准值可以推出为1460(1500 – 20 -20)。

只要TCP通道都遵守这个MSS标准值，那么就可以避免TCP报文会在网络层被IP协议进行分片处理。但是其实很多TCP的MSS并不是标准值。

在正常使用环境中，一个MSS的值被确定在三次握手的前两次包含SYN标志的握手中，首先第一个握手时，客户端在TCP协议报文的可选项中携带客户端”支持”的MSS大小，而第二次握手，服务器端会在回复报文中的可选项中携带服务器端”支持”的MSS大小，客户端采用两者之中最小的一个MSS值作为最后采用的大小。

------

## 那么TCP分段数据是怎么重组的呢？

在接收方中有专门存放TCP分段报文的数据结构，一个二维链表，**横轴为Socket对，即接收方不同的Socket组成的一个Socket集合作为头节点集合，每当有新的Socket来时，就新在横轴上新增一个头节点。纵轴上是当前Socket的分段TCP信息按顺序排序的节点集合。这个二维链表也被我们称为”重装表”**。

我们来看看TCP完整报文被分段之后的分段报文来到接收方之后的被接收流程：

1）每到来一个TCP数据包，先将其数据的Socket组成信息，也就是源IP，源端口号，目标IP，目标端口号提取出来，先在横轴头节点中遍历判断是不是有相同的Socket头节点，如果有的话，就通过seq号来判断这个TCP数据包在这条链表中应该在的位置，并插入。反之当没有相同的Socket头节点时，就表示是一个新的连接，创建新Socket头节点，并把这个TCP数据包放入这个头节点对应的链表中。

2）每当在某个Socket头节点对应的链表中插入一个节点的时候，就要判断一下，这个TCP分段报文是否发送完毕，即已经到齐，如果确认到齐之后，就把这条链表中的所有节点顺序取出，拼接出一条完整的应用层报文，然后释放该链表。（待议）

------

## 如何在重装表中判断TCP报文是否全部发送完毕？

重装表使用三个字段来判断一个TCP报文是否全部发送完毕。

1）count计数器：表示当前链表中所有tcp数据段数据部分的长度之和，每当在该链表中加入一个新字段，那么当前链表的count就会累加上该TCP数据段的数据部分的长度。

2）syn_seq：本次tcp连接的第一个数据包的seq号，也就是第一次握手时候的seq号。

3）fin_seq：本次tcp连接的最后一个数据包的seq号，也就是第三次挥手时候的seq号。

**当fin_seq – syn_seq 与count相等的时候，就说明tcp数据段已经到齐，负责就是没有到齐。**

在tcp长连接而且基于流式传输时，我们可不会一次就传送一个数据就结束，而是传输多个数据之后才会关闭TCP通道，也就是发送fin报文。我们总不能等到最后都传完了，服务器那边才提取报文吧。

这就涉及到TCP流式传输在服务端如何定义获取报文的边界问题。

**短连接完全可以通过一个TCP连接的开启和关闭判断数据的边界！！**

------

## TCP流式传输在服务端边界问题

即当我们在TCP通道中连续发送好几个数据，由于TCP是流式传输，而不是分包传输，所以服务器端那边可不知道你一个数据的边界在哪。如果放任不管的话，可能就会发生数据被柔和在一起被服务器端读取的情况。

一般来说我们要解决这个问题有三种方式：

1）**固定包长的数据包**。顾名思义，也即是固定每一个协议包的长度。比如我们规定一个数据包的长度必须为32个字节，那么每次服务器端收满32个字节就取出来解析（如果不够就先存起来，知道取够32个字节）。个人感觉Netty框架的ByteToMessageDecoder解码器类就是这么处理的。

2）**以指定的字符或者字符串为包的结束标志**。这种处理方式还是很常见的，也就是在字节流中遇到特殊的符号值就认为到了一个包的末尾了。比如在一段数据后面加上”\r\n”表示一个”包”的结束。服务器端接受TCP字节流时读取到\r\n就知道把之前的数据当作一个”包”。

3）**包头+包体的格式**。即模拟成包头和包体，包头是固定大小的，而且包头中必须含有一个字段来说明接下来包体有多大。