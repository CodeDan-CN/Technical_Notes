## 讲解CAP理论

### **CAP理论是有三大特性组成**

1）C(一致性)：所有的节点上的数据时刻保持同步。同时一致性也被称为原子对象，任何的读写都应该看起来是“原子“的，或串行的。写后面的读一定能读到前面写的内容。所有的读写请求都好像被全局排序。

2）A(可用性)：对任何非失败节点都应该在**有限时间**内给出请求的回应。

3）P(分区容错性)：一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。所以分区容忍性也就是节点的数据冗余的程度。

------

### CAP三角关系讲解

CAP之间的关系制衡三角关系，我们从P也就是分区容错性来解析这个三角关系。

(1)首先我们想要提升分区容错性，那就要把尽可能多的数据复杂到所有节点中，这样哪怕进行了网络分区，服务也能正常提供数据进行返回。

(2)但是这样就会带来一致性问题，毕竟这么多冗余数据，一旦其中一个发生改变，那么其他节点中的相同数据是否也要跟着改变。如果我们希望所有的冗余数据也要一起进行改变的话，那我们的一次数据流程就必须为请求修改当前节点数据—->等待所有节点修改数据—->修改完成。

(3)这样就会带来新问题，也就是可用性问题。在保证一致性的前提下，等待所有节点修改数据是顺序执行保证容忍数据安全的，也就是等待区中的节点是无法响应别的请求的，如果节点特别多，那么这个等待时间就会越来越长，可用性也就越来越低。

**综上所属当我们要保证P(分区容错性)一定成立的情况下，我们只能在C(一致性)和A(可用性)之间做一个抉择。一旦选择C，那么A可用性就会低下。相反选择A可用性，那么C一致性就无法保证。**

------

### CAP搭配讲解

CP：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。

AP：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。



------

------

## 讲解BASE理论

BASE理论则是对CAP理论的平衡化，不再是CP without A或者AP without C这种极端设计，而是存在缓冲的中间态，也就是降低一定的C(一致性)，拉高一点A(可用性)并保持P(分区容错性)的状态等等。

**BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。**

**其核心思想是：既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。**

我们来看看Base理论的B，S，E到底该怎么解读：

(1)**Basically Avaliable(基本可用)**：假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：

a.**响应时间上的损失**：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。

b.**功能上的损失**：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。

(2)**Soft State(软状态)**：要求多个节点的数据副本都是一致的，这是一种“硬状态”，相反允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。

(3)**Eventually Consistent(最终一致性)**：对于系统来说不可能一直处于软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。而在实际工程实践中，最终一致性分为5种：

a.因果一致性：因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。

b.读己之所写：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。

c.会话一致性：将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。

d.单调读一致性：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。

e.单调写一致性：一个系统要能够保证来自同一个节点的写操作被顺序的执行。