## 有序性与Volatile关键字

我们在学习JMM内存模型的时候，关于有序性可以说是重点中的重点，当时说的解决方案就是使用volatile关键字去修饰变量，**利用volatile关键字的写屏障完成volation关键字修饰变量之后插入写屏障，保证写操作成功写入到工作内存后被刷入主存中**(线程不会直接操作主存，一般是通过写入到工作内存，然后同步到主存中)。

而写屏障也可以说是Happens-Before规则中的实现，那么Happens-Before到底是什么规则？就要从JMM设计意图开始理解他们两个的关系。

------

## JMM与Happens-Befor的关系

JMM在设计之初，对于编译器和处理器来说，当时是怎么让他们编译/处理的越来越快，而要到达着目的就要尽量减少JMM对于编译器和处理器的约束，那么对于他们来说就需要JMM是一个弱内存模型。

但是对于我们程序员来说，我们需要一个强大规则来进行代码编写，这样会我们按照规则来编写可以降低编写难度。也就是我们需要一个强内存模型。

上述的两点明显是冲突的，根本不可能满足两方需求，所以JMM在设计的时候就指定了两个策略：

1）**对于会影响到结果的重排序，JMM要求编译器和处理器必须禁止这种重排序(按照Happens-Before规矩来办事)**

2）**对于不会影响到结果的重排序，JMM要求编译器和处理器放开约束，尽可能的去优化指令执行速度。**

我们可以得到以下结论：

**Happens-Before就是JMM模型在面对能够影响到结果的重排序时，对编译器和处理器额外添加的约束规则**。**从而保证操作的正确性。**

------

## Happens-Before六大规则解析

Happens-Before理解起来就是：**前一个操作的结果对于后续操作时是可见的**。

也就是说前一个操作必须完成对于主存中数据的修改，才能保证后续操作能从主存中获取到最新数据。

**规则一：程序顺序规则(关键在于一个线程内，多个线程共同参与，此规则无效)**

在一个线程内一段代码的执行结果是有序的。就是哪怕一个线程执行时还是会发生指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。

------

**规则二：监视器锁规则**

就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！

------

**规则三：volatile变量规则**

即volatile关键字的读写屏障，**对于读屏障来说，位于volatile修饰变量之前，表示在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；**

**对于写屏障来说，位于volatile修饰变量之后，表示在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。**

------

**规则四：传递性规则**

如果A happens-before B，B happens-before C，那么A happens-before C。

```
class VolatileExample {
  String name = "default" ;
  volatile boolean flag = false;
  public void writer() {
    name = "CodeDan";
    flag = true;
  }
  public void reader() {
    if (flag == true) {
      System.out.println(name);
    }
  }
}
```

1. name = “CodeDan” Happens-Before flag = true ，这是规则 1 的内容；
2. flag = true Happens-Before flag == true，这是规则 3 的内容 。
3. 再根据这个传递性规则，我们得到结果：name = “CodeDan” Happens-Before flag == true。这意味着什么呢？

**这就是happens-before传递性规则。**

------

**规则五：start()规则**

即主线程A启动子线程B后，子线程可以看到主线程在启动子线程之前的操作。

------

**规则六：join调度规则**

如果线程A执行线程BThread.join()并成功返回，那么线程B的操作对于线程A可见**。**也就是可以被称为B happens-before A。

------

## Happens-Before规则总结

在 Java 语言里面，Happens-Before 的语义本质上是一种可见性。

**JMM的设计分为两部分**，一部分是**面向我们程序员**提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解 happens-before规则，就可以编写并发安全的程序了。 另一部分是**针对JVM实现的**，为了尽可能少的对编译器和处理器做约束，从而提高性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。 我们只需要关注前者就好了，也就是理解happens-before规则。毕竟我们是做程序员的，术业有专攻，能写出安全的并发程序就好了